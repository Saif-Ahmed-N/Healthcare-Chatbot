ACTIONS_LOGIC.PY

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from typing import Dict, Any, List, Optional
from datetime import datetime, date, time
import re
from fastapi import HTTPException
import json

# --- Database & API Imports ---
from .models import Patient, Doctor, AvailabilitySlot, Appointment
from .schemas import PatientCreate, PatientPublic, PatientLookupRequest, PatientVerifyRequest, KnowledgeQueryRequest, AppointmentCreate
from . import patient_api, knowledge_api
from . import models as db_models

# This is the standard format for an action response.
ActionResponse = Dict[str, Any]

# -------------------------------------------------------------------------
# RASA SDK EVENT REPLACEMENTS (JSON Helpers)
# -------------------------------------------------------------------------

def _slot_set(key: str, value: Any) -> Dict:
    """Returns the JSON for a SlotSet event."""
    return {"event": "slot", "name": key, "value": value}

def _active_loop(name: Optional[str]) -> Dict:
    """Returns the JSON for an ActiveLoop event."""
    return {"event": "active_loop", "name": name}

def _followup_action(name: str) -> Dict:
    """Returns the JSON for a FollowupAction event."""
    return {"event": "followup", "name": name}

def _reset_slots() -> Dict: 
    """Returns the JSON for an AllSlotsReset event."""
    return {"event": "reset_slots"}

def _session_started() -> Dict:
    """Returns the JSON for a SessionStarted event."""
    return {"event": "session_started"}

def create_rasa_response(events: List[Dict], responses: List[Dict]) -> ActionResponse:
    """Standardizes the return format for the Rasa Core webhook."""
    return {"events": events, "responses": responses}

def utter(message: str, buttons: Optional[List[Dict]] = None) -> Dict:
    """Helper to create a simple 'utter_message' response."""
    response = {"text": message}
    if buttons:
        response["buttons"] = buttons
    return response

# -------------------------------------------------------------------------
# CORE FLOW 1: GREET & RESTART
# -------------------------------------------------------------------------

async def handle_session_start(tracker: Dict, session: AsyncSession) -> ActionResponse:
    events = [_reset_slots(), _session_started()]
    message = "Hello! I am your Healthcare Assistant. Do you need to register or log in?"
    buttons = [
        {"title": "Register", "payload": "/register_user"},
        {"title": "Login", "payload": "/log_in_user"},
    ]
    return create_rasa_response(events, [utter(message, buttons)])

async def handle_restart_conversation(tracker: Dict, session: AsyncSession) -> ActionResponse:
    return await handle_session_start(tracker, session)

async def handle_suggest_next_steps(tracker: Dict, session: AsyncSession) -> ActionResponse:
    patient_id = tracker.get("slots", {}).get("patient_id")
    user_name = tracker.get("slots", {}).get("user_name")

    if patient_id and user_name:
        message = f"Welcome back, {user_name}! How can I help you today?"
        buttons = [
            {"title": "Book an Appointment", "payload": "/book_appointment"},
            {"title": "Check My Appointments", "payload": "/check_appointments"}, 
            {"title": "Ask Medical Info", "payload": "/ask_medical_info"},
            {"title": "Check Insurance", "payload": "/ask_insurance"},
            {"title": "Contact My Doctor", "payload": "/contact_physician"}
        ]
    else:
        message = "How can I assist you today? You can log in or register to get started."
        buttons = [
            {"title": "Register", "payload": "/register_user"}, 
            {"title": "Login", "payload": "/log_in_user"},
            {"title": "Ask a General Question", "payload": "/ask_medical_info"}
        ]
    return create_rasa_response([_slot_set("user_context", "suggested_options")], [utter(message, buttons)])

# -------------------------------------------------------------------------
# CORE FLOW 2: REGISTRATION (simple_info_form)
# -------------------------------------------------------------------------

async def handle_validate_simple_info_form(tracker: Dict, session: AsyncSession) -> ActionResponse:
    slots = tracker.get("slots", {})
    requested_slot = slots.get("requested_slot")
    
    if not slots.get("patient_name"):
        return create_rasa_response([_slot_set("requested_slot", "patient_name")], [utter("To start your registration, please provide your full name.")])
        
    if not slots.get("patient_email"):
        return create_rasa_response([_slot_set("requested_slot", "patient_email")], [utter(f"Thank you, {slots['patient_name']}. What is your best email address?")])

    if requested_slot == "patient_email":
        email_regex = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        if not re.fullmatch(email_regex, slots.get("patient_email", "")):
            return create_rasa_response([_slot_set("patient_email", None)], [utter("That doesn't look like a valid email. Please try again (e.g., user@domain.com).")])

    if not slots.get("patient_phone"):
        return create_rasa_response([_slot_set("requested_slot", "patient_phone")], [utter("Got it. And finally, what is a good phone number to reach you?")])

    if requested_slot == "patient_phone":
        clean_phone = re.sub(r'[\s\-()]+', '', str(slots.get("patient_phone", "")))
        if not (clean_phone.isdigit() and len(clean_phone) >= 7):
            return create_rasa_response([_slot_set("patient_phone", None)], [utter("Please provide a valid phone number (at least 7 digits).")])
        else:
            return create_rasa_response([_slot_set("patient_phone", clean_phone), _slot_set("requested_slot", None)], [])

    return create_rasa_response([_slot_set("requested_slot", None)], [])

async def handle_create_new_patient(tracker: Dict, session: AsyncSession) -> ActionResponse:
    slots = tracker.get("slots", {})
    patient_data = PatientCreate(
        name=slots.get("patient_name"),
        email=slots.get("patient_email"),
        phone=slots.get("patient_phone")
    )
    try:
        new_patient = await patient_api.register_new_patient(patient_data, session)
        events = [
            _slot_set("patient_id", new_patient.patient_id),
            _slot_set("user_name", new_patient.name),
            _slot_set("user_context", "new_registration"),
            _active_loop(None), 
            _slot_set("requested_slot", None),
            _followup_action("action_suggest_next_steps")
        ]
        return create_rasa_response(events, [utter(f"✅ Registration Complete! Welcome, {new_patient.name}! Your Patient ID is **{new_patient.patient_id}**. Please save this for future logins.")])
    except HTTPException as e:
        return create_rasa_response(
            [_slot_set("patient_email", None), _slot_set("requested_slot", "patient_email")],
            [utter(f"Error: {e.detail} Please provide a different email address.")]
        )
    except Exception as e:
        print(f"ACTION ERROR (create_new_patient): {e}")
        return create_rasa_response([_active_loop(None)], [utter("I'm sorry, a critical error occurred with our registration system. Please try again later.")])

# -------------------------------------------------------------------------
# CORE FLOW 3: LOGIN / LOOKUP
# -------------------------------------------------------------------------

async def handle_login_patient(tracker: Dict, session: AsyncSession) -> ActionResponse:
    patient_id = tracker.get("slots", {}).get("patient_id")
    if not patient_id:
        patient_id = tracker.get("latest_message", {}).get("text")
    patient_id_input = str(patient_id).strip().upper()
    if not patient_id_input.startswith("PID-") and len(patient_id_input) == 8:
        patient_id_to_check = f"PID-{patient_id_input}"
    else:
        patient_id_to_check = patient_id_input
    try:
        verify_request = PatientVerifyRequest(patient_id=patient_id_to_check)
        patient = await patient_api.verify_patient_id(verify_request, session)
        events = [
            _slot_set("patient_id", patient.patient_id),
            _slot_set("user_name", patient.name),
            _slot_set("user_context", "login_success"),
            _followup_action("action_suggest_next_steps")
        ]
        return create_rasa_response(events, [])
    except HTTPException as e:
        return create_rasa_response([_slot_set("patient_id", None)], [utter(f"Login Failed: {e.detail} Please try again.")])
    except Exception as e:
        print(f"ACTION ERROR (login_patient): {e}")
        return create_rasa_response([_slot_set("patient_id", None)], [utter("I'm sorry, a system error occurred while trying to log you in.")])

async def handle_validate_lookup_form(tracker: Dict, session: AsyncSession) -> ActionResponse:
    slots = tracker.get("slots", {})
    requested_slot = slots.get("requested_slot")
    if not slots.get("patient_email"):
        return create_rasa_response([_slot_set("requested_slot", "patient_email")], [utter("No problem. Please enter the email address you registered with.")])
    if requested_slot == "patient_email":
        email_regex = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        if not re.fullmatch(email_regex, slots.get("patient_email", "")):
            return create_rasa_response([_slot_set("patient_email", None)], [utter("That email looks invalid. Please try again (e.g., user@domain.com).")])
    return create_rasa_response([_slot_set("requested_slot", None)], [])

async def handle_lookup_patient_id(tracker: Dict, session: AsyncSession) -> ActionResponse:
    email = tracker.get("slots", {}).get("patient_email")
    try:
        lookup_request = PatientLookupRequest(email=email)
        patient = await patient_api.lookup_patient_by_email(lookup_request, session)
        events = [
            _slot_set("patient_id", patient.patient_id),
            _slot_set("user_name", patient.name),
            _slot_set("user_context", "login_success"),
            _active_loop(None),
            _slot_set("requested_slot", None),
            _followup_action("action_suggest_next_steps")
        ]
        return create_rasa_response(events, []) 
    except HTTPException as e:
        message = f"Sorry, {e.detail}. Let's get you registered as a new patient."
        events = [
            _slot_set("patient_email", email),
            _active_loop(None),
            _followup_action("simple_info_form")
        ]
        return create_rasa_response(events, [utter(message)])

# -------------------------------------------------------------------------
# TRANSACTIONAL FLOWS (APPOINTMENT)
# -------------------------------------------------------------------------

SPECIALTY_KEYWORD_MAP = {
    "Cardiology": ["heart", "chest pain", "cardio", "blood pressure", "palpitations"],
    "Neurology": ["headache", "migraine", "nerves", "seizure", "dizziness"],
    "Dermatology": ["skin", "rash", "mole", "acne", "psoriasis"],
    "Orthopedics": ["bone", "joint", "knee", "shoulder", "back pain", "fracture"],
    "Endocrinology": ["diabetes", "thyroid", "hormone", "sugar checkup"],
    "Pulmonology": ["lung", "lungs", "breathing", "cough", "asthma", "shortness of breath", "lung issues"],
    "General Practice": ["fever", "flu", "cold", "checkup", "general", "sick", "stomach pain", "vomiting"],
}

def _find_specialty(reason: str) -> str:
    """Finds a specialty based on keywords in the reason."""
    reason_lower = reason.lower()
    for specialty, keywords in SPECIALTY_KEYWORD_MAP.items():
        if any(keyword in reason_lower for keyword in keywords):
            return specialty
    return "General Practice"


async def handle_validate_appointment_form(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """
    Validates the multi-step appointment booking form.
    This function now performs its own database queries to prevent session conflicts.
    """
    slots = tracker.get("slots", {})
    patient_id = slots.get("patient_id")
    requested_slot = slots.get("requested_slot")

    # --- Step 0: Check Login ---
    if not patient_id:
        return create_rasa_response(
            [_active_loop(None), _slot_set("requested_slot", None), _followup_action("utter_ask_account_type")],
            [utter("You must be logged in to book an appointment. Let's start with that.")]
        )

    # --- Step 1: Request Reason ---
    if not slots.get("appointment_reason"):
        return create_rasa_response([_slot_set("requested_slot", "appointment_reason")], [utter("Sure, I can schedule that. What is the main reason for your visit (e.g., 'severe headache', 'yearly checkup')?")])

    # --- Step 2: Request Doctor (with direct DB query) ---
    if not slots.get("doctor_name"):
        reason = slots.get("appointment_reason", "")
        specialty = _find_specialty(reason)
            
        try:
            # --- Direct DB Query ---
            result = await session.execute(
                select(db_models.Doctor).where(db_models.Doctor.specialty.ilike(f"%{specialty}%"))
            )
            doctors = result.scalars().all()
            if not doctors:
                raise HTTPException(status_code=404) # Trigger the 'except' block
            # --- End Query ---

            buttons = [{"title": doc.name, "payload": f"/inform_doctor_name{{\"doctor_name\":\"{doc.name}\"}}"} for doc in doctors]
            buttons.append({"title": "First Available (Any)", "payload": "/skip_info"}) 

            message = f"Got it. For '{reason}', I recommend a **{specialty}** doctor. Who would you like to see?"
            
            events = [
                _slot_set("requested_slot", "doctor_name"),
                _slot_set("department", specialty) 
            ]
            return create_rasa_response(events, [utter(message, buttons)])
        
        except HTTPException:
            # Fallback to General Practice
            print(f"No specialists found for '{specialty}', falling back to General Practice.")
            result_gp = await session.execute(
                select(db_models.Doctor).where(db_models.Doctor.specialty == "General Practice")
            )
            doctors_gp = result_gp.scalars().all()
            buttons_gp = [{"title": doc.name, "payload": f"/inform_doctor_name{{\"doctor_name\":\"{doc.name}\"}}"} for doc in doctors_gp]
            buttons_gp.append({"title": "First Available (Any)", "payload": "/skip_info"})

            return create_rasa_response(
                [_slot_set("requested_slot", "doctor_name"), _slot_set("department", "General Practice")], 
                [utter(f"I couldn't find any specific specialists for '{reason}', so I'll check General Practice. Who would you like to see?", buttons_gp)]
            )
        except Exception as e:
            print(f"ACTION ERROR (validate_appointment_form): {e}")
            return create_rasa_response(
                [_active_loop(None), _followup_action("action_suggest_next_steps")],
                [utter(f"I'm sorry, an internal system error occurred. Let's return to the main menu.")]
            )
            
    # --- Step 3: Request Date ---
    if not slots.get("appointment_date"):
        events = [_slot_set("requested_slot", "appointment_date")]
        # --- [START] FIX: ALWAYS SEND CALENDAR PAYLOAD ---
        responses = [
            utter("What date would you like for your appointment? Please select from the calendar below."),
            {"custom": {"calendar": True}} 
        ]
        # --- [END] FIX ---
        return create_rasa_response(events, responses)

    # --- Step 4: Validate Date & Request Time (with direct DB query) ---
    if requested_slot == "appointment_date":
        try:
            date_str = slots.get("appointment_date", "")
            if "T" in date_str: date_str = date_str.split("T")[0]
            else: date_str = date_str[:10]
            parsed_date = datetime.strptime(date_str, "%Y-%m-%d").date()
            if parsed_date < date.today():
                # --- [START] FIX: RE-SEND CALENDAR ON INVALID DATE ---
                return create_rasa_response(
                    [_slot_set("appointment_date", None)], 
                    [utter("I can only schedule appointments for today or a future date. Please choose a new date."), {"custom": {"calendar": True}}]
                )
                # --- [END] FIX ---
            events = [_slot_set("appointment_date", date_str)]
        except Exception:
             # --- [START] FIX: RE-SEND CALENDAR ON PARSE ERROR ---
            return create_rasa_response(
                [_slot_set("appointment_date", None)], 
                [utter("That date doesn't look valid. Please select from the calendar."), {"custom": {"calendar": True}}]
            )
             # --- [END] FIX ---
    
    if not slots.get("appointment_time"):
        # --- Direct DB Query for Doctor ID ---
        all_doctors_result = await session.execute(select(db_models.Doctor))
        doctor_id_map = {doc.name: doc.id for doc in all_doctors_result.scalars().all()}
        default_doc_id = next(iter(doctor_id_map.values()), 1) 
        doc_name = slots.get("doctor_name", "First Available")
        doc_id = doctor_id_map.get(doc_name, default_doc_id)
        if doc_name.lower() == "first available":
            doc_id = default_doc_id
        # --- End Query ---

        date_str = slots.get("appointment_date", "")[:10]
        
        try:
            # --- Direct DB Query for Availability ---
            doctor = await session.get(db_models.Doctor, doc_id)
            if not doctor:
                raise HTTPException(status_code=404, detail="Doctor not found.")

            result = await session.execute(
                select(db_models.AvailabilitySlot)
                .where(db_models.AvailabilitySlot.doctor_id == doc_id)
                .where(db_models.AvailabilitySlot.date == datetime.strptime(date_str, "%Y-%m-%d").date())
                .where(db_models.AvailabilitySlot.is_booked == False)
                .order_by(db_models.AvailabilitySlot.time)
            )
            available_slots = result.scalars().all()
            available_times_24hr = [s.time.strftime("%H:%M") for s in available_slots]
            # --- End Query ---
            
            if not available_times_24hr:
                # --- [START] FIX: RE-SEND CALENDAR IF NO SLOTS ---
                return create_rasa_response(
                    [_slot_set("appointment_date", None), _slot_set("requested_slot", "appointment_date")],
                    [utter(f"I'm sorry, {doctor.name} has no available slots on {date_str}. Please choose a different date."), {"custom": {"calendar": True}}]
                )
                # --- [END] FIX ---
            
            message = f"{doctor.name} is available on {date_str}. Please select an available time from the clock."
            custom_payload = {"custom": {"time_picker": True, "available_times": available_times_24hr}}
            
            return create_rasa_response([_slot_set("requested_slot", "appointment_time")], [utter(message), custom_payload])

        except Exception as e:
            print(f"ACTION ERROR (get_availability): {e}")
            return create_rasa_response(
                [_slot_set("appointment_date", None), _slot_set("requested_slot", "appointment_date")],
                [utter("I'm sorry, I couldn't fetch the schedule. Please try a different date.")]
            )
            
    # All slots are filled
    return create_rasa_response(
        [
            _slot_set("requested_slot", None), 
            _followup_action("action_submit_appointment") # <--- THIS WAS MISSING
        ], 
        []
    )


async def handle_submit_appointment(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """
    Submits the appointment to the backend API.
    This function now performs its own database queries to prevent session conflicts.
    """
    slots = tracker.get("slots", {})
    
    try:
        # --- 1. Get Doctor ID ---
        all_doctors_result = await session.execute(select(db_models.Doctor))
        doctor_id_map = {doc.name: doc.id for doc in all_doctors_result.scalars().all()}
        default_doc_id = next(iter(doctor_id_map.values()), 1)
        doc_name = slots.get("doctor_name", "First Available")
        doc_id = doctor_id_map.get(doc_name, default_doc_id)
        if doc_name.lower() == "first available":
            doc_id = default_doc_id

        # --- 2. Parse Time ---
        time_str = slots.get("appointment_time", "")
        if "T" in time_str: time_str = time_str.split("T")[1][:5]
        try:
            parsed_time = datetime.strptime(time_str, "%H:%M").time()
        except ValueError:
            parsed_time = datetime.strptime(time_str, "%I:%M %p").time()
            
        if parsed_time.minute not in (0, 30):
            events = [
                _slot_set("appointment_time", None), 
                _slot_set("requested_slot", "appointment_time"),
                _followup_action("appointment_form")
            ]
            return create_rasa_response(events, [utter("We only offer slots on the hour or half-hour (e.g., 11:00 or 11:30). Please select an available time.")])

        # --- 3. Parse Date ---
        parsed_date = datetime.strptime(slots.get("appointment_date")[:10], "%Y-%m-%d").date()

    except Exception as e:
        print(f"ACTION ERROR (submit_appointment time parse): {e} (Value was: {slots.get('appointment_time')})")
        events = [
            _slot_set("appointment_time", None), 
            _slot_set("requested_slot", "appointment_time"), 
            _followup_action("appointment_form") 
        ]
        return create_rasa_response(events, [utter("That time format was invalid. Please select an available time from the clock.")])

    try:
        # --- 4. Direct DB Query: Find Patient ---
        patient_result = await session.execute(
            select(db_models.Patient).where(db_models.Patient.patient_id == slots.get("patient_id"))
        )
        patient = patient_result.scalars().first()
        if not patient:
            raise HTTPException(status_code=404, detail="Patient ID not found.")

        # --- 5. Direct DB Query: Find Slot ---
        slot_result = await session.execute(
            select(db_models.AvailabilitySlot)
            .options(selectinload(db_models.AvailabilitySlot.doctor))
            .where(db_models.AvailabilitySlot.doctor_id == doc_id)
            .where(db_models.AvailabilitySlot.date == parsed_date)
            .where(db_models.AvailabilitySlot.time == parsed_time)
            .where(db_models.AvailabilitySlot.is_booked == False)
        )
        slot_to_book = slot_result.scalars().first()
        
        if not slot_to_book:
            raise HTTPException(status_code=409, detail="This slot is no longer available. Please select a different time.")

        # --- 6. Book the Appointment ---
        slot_to_book.is_booked = True
        session.add(slot_to_book)

        new_appointment = db_models.Appointment(
            patient_id=patient.id,
            doctor_id=doc_id,
            slot_id=slot_to_book.id,
            reason=slots.get("appointment_reason"),
            status="Scheduled"
        )
        session.add(new_appointment)
        
        # We need to flush to get the new_appointment.id
        await session.flush()
        
        # --- 7. Load all data for the success message ---
        await session.refresh(new_appointment)
        await session.refresh(new_appointment.patient)
        await session.refresh(new_appointment.doctor)
        await session.refresh(new_appointment.slot)

        message = f"""
✅ **Success! Your appointment is confirmed.**

Here are the details:
- **Patient:** {new_appointment.patient.name}
- **Doctor:** {new_appointment.doctor.name}
- **Specialty:** {new_appointment.doctor.specialty}
- **Reason:** {new_appointment.reason}
- **Date:** {new_appointment.slot.date.strftime('%B %d, %Y')}
- **Time:** {new_appointment.slot.time.strftime('%I:%M %p')}

We look forward to seeing you.
"""
        
        events = [
            _active_loop(None),
            _slot_set("requested_slot", None),
            _slot_set("appointment_date", None),
            _slot_set("appointment_time", None),
            _slot_set("appointment_reason", None),
            _slot_set("doctor_name", None),
            _slot_set("department", None),
        ]
        return create_rasa_response(events, [utter(message, buttons=[{"title": "Main Menu", "payload": "/show_options"}])])

    except HTTPException as e:
        print(f"Booking failed: {e.detail}")
        
        events = [
            _slot_set("appointment_date", None), 
            _slot_set("appointment_time", None), 
            _slot_set("requested_slot", "appointment_date"), # Re-ask for the date first
            _followup_action("appointment_form") # Re-activate the form
        ]
        
        # --- FIX: Send calendar on booking failure too ---
        return create_rasa_response(
            events,
            [utter(f"Booking failed: {e.detail}. Let's try selecting a new date.", buttons=None), {"custom": {"calendar": True}}]
        )
    
    except Exception as e:
        print(f"ACTION ERROR (submit_appointment): {e}")
        return create_rasa_response(
            [_active_loop(None), _followup_action("action_suggest_next_steps")],
            [utter(f"I'm sorry, an internal error occurred while running 'action_submit_appointment'. Please check the server logs.")]
        )

async def handle_show_appointments(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """
    Fetches and displays the patient's upcoming appointments.
    """
    patient_id = tracker.get("slots", {}).get("patient_id")
    if not patient_id:
        return create_rasa_response([_followup_action("utter_ask_account_type")], [utter("Please log in to see your appointments.")])

    try:
        # --- Direct DB Query ---
        result = await session.execute(
            select(db_models.Appointment)
            .join(db_models.Patient)
            .where(db_models.Patient.patient_id == patient_id)
            .options(
                selectinload(db_models.Appointment.patient),
                selectinload(db_models.Appointment.doctor),
                selectinload(db_models.Appointment.slot)
            )
            .order_by(db_models.Appointment.id.desc())
        )
        appointments = result.scalars().all()
        # --- End Query ---
        
        if not appointments:
            return create_rasa_response([], [utter("You have no upcoming appointments scheduled.", buttons=[{"title": "Main Menu", "payload": "/show_options"}])])
        
        message_parts = ["Here are your upcoming appointments:\n"]
        for i, appt in enumerate(appointments, 1):
            message_parts.append(
                f"**{i}. {appt.reason} with {appt.doctor.name}**\n"
                f"   - **When:** {appt.slot.date.strftime('%A, %B %d')} at {appt.slot.time.strftime('%I:%M %p')}\n"
                f"   - **Status:** {appt.status}\n"
            )
        
        return create_rasa_response([], [utter("\n".join(message_parts), buttons=[{"title": "Main Menu", "payload": "/show_options"}])])

    except Exception as e:
        print(f"ACTION ERROR (show_appointments): {e}")
        return create_rasa_response([], [utter("I'm sorry, I couldn't fetch your appointments due to a system error.", buttons=[{"title": "Main Menu", "payload": "/show_options"}])])

# -------------------------------------------------------------------------
# KNOWLEDGE FLOWS
# -------------------------------------------------------------------------

async def handle_validate_medical_form(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """Asks for the medical query."""
    if not tracker.get("slots", {}).get("medical_query"):
        return create_rasa_response([_slot_set("requested_slot", "medical_query")], [utter("Of course. What is your medical question? (e.g., 'what are the symptoms of the flu?')")])
    return create_rasa_response([_slot_set("requested_slot", None)], [])

async def handle_llm_response(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """
    Handles 'ask_medical_info' and 'nlu_fallback'.
    """
    query = tracker.get("slots", {}).get("medical_query")
    patient_id = tracker.get("slots", {}).get("patient_id")
    
    if not query:
        query = tracker.get("latest_message", {}).get("text")
        
    response = await knowledge_api.handle_llm_query(
        KnowledgeQueryRequest(query=query, patient_id=patient_id)
    )
    
    return create_rasa_response([_slot_set("medical_query", None)], [utter(response.response, buttons=[{"title": "Main Menu", "payload": "/show_options"}])])

async def handle_validate_insurance_form(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """Asks for the insurance query."""
    if not tracker.get("slots", {}).get("insurance_query"):
        return create_rasa_response([_slot_set("requested_slot", "insurance_query")], [utter("I can help with that. What is your question about insurance? (e.g., 'what does my plan cover?')")])
    return create_rasa_response([_slot_set("requested_slot", None)], [])

async def handle_rag_insurance_query(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """
    Handles 'ask_insurance'.
    """
    query = tracker.get("slots", {}).get("insurance_query")
    
    rag_result = await knowledge_api.handle_rag_query(
        KnowledgeQueryRequest(query=query)
    )
    
    answer = rag_result.response
    sources = rag_result.sources
    
    if sources:
        source_text = "\n*(Source: " + ", ".join(sources) + ")*"
        answer += source_text
        
    return create_rasa_response([_slot_set("insurance_query", None)], [utter(answer, buttons=[{"title": "Main Menu", "payload": "/show_options"}])])

# -------------------------------------------------------------------------
# OTHER ACTIONS
# -------------------------------------------------------------------------

async def handle_validate_physician_form(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """Smart Contact Flow: Offers buttons for past doctors + 'Other'."""
    slots = tracker.get("slots", {})
    patient_id = slots.get("patient_id")
    doc_name = slots.get("doctor_name")

    # --- FALLBACK: Manually extract doctor name from payload if missing ---
    if not doc_name:
        latest_msg = tracker.get("latest_message", {}).get("text", "")
        if latest_msg.startswith("/inform"):
            try:
                # Try to parse: /inform{"doctor_name":"Alex Ray"}
                json_str = latest_msg.replace("/inform", "").strip()
                data = json.loads(json_str)
                if "doctor_name" in data:
                    doc_name = data["doctor_name"]
            except:
                # Fallback for simple text if JSON fails
                pass

    print(f"[DEBUG] validate_physician_form | Doc: {doc_name} | Patient: {patient_id}")

    # --- Step 1: Doctor Selection ---
    if not doc_name:
        if patient_id:
            try:
                # Find past doctors
                result = await session.execute(
                    select(db_models.Appointment)
                    .join(db_models.Patient).where(db_models.Patient.patient_id == patient_id)
                    .options(selectinload(db_models.Appointment.doctor))
                    .order_by(db_models.Appointment.id.desc())
                )
                appointments = result.scalars().all()
                
                unique_doctors = {}
                for appt in appointments:
                    if appt.doctor.name not in unique_doctors:
                        unique_doctors[appt.doctor.name] = appt.doctor

                if unique_doctors:
                    buttons = []
                    for name in unique_doctors.keys():
                        # Ensure nice display format
                        title = name if name.strip().lower().startswith("dr.") else f"Dr. {name}"
                        buttons.append({"title": title, "payload": f"/inform{{\"doctor_name\":\"{name}\"}}"})
                    
                    buttons.append({"title": "Other Doctor", "payload": "/inform{\"doctor_name\":\"Other\"}"})
                    
                    return create_rasa_response(
                        [_slot_set("requested_slot", "doctor_name")],
                        [utter("Which of your doctors would you like to contact?", buttons=buttons)]
                    )
            except Exception as e:
                print(f"ACTION ERROR (validate_physician_form): {e}")
        
        return create_rasa_response([_slot_set("requested_slot", "doctor_name")], [utter("Which doctor would you like to contact?")])

    # --- Step 1.5: Handle "Other" ---
    if doc_name.lower() == "other":
         return create_rasa_response(
             [_slot_set("doctor_name", None), _slot_set("requested_slot", "doctor_name")], 
             [utter("Please type the name of the doctor you wish to reach.")]
         )

    # --- Step 2: Message Content ---
    if not slots.get("message_content"):
         display_name = doc_name.replace("Dr.", "").strip()
         return create_rasa_response(
             # CRITICAL: Force set the doctor_name slot now that we found it
             [_slot_set("doctor_name", doc_name), _slot_set("requested_slot", "message_content")], 
             [utter(f"What is your message for Dr. {display_name}?")]
         )

    return create_rasa_response([_slot_set("requested_slot", None)], [])


async def handle_send_physician_message(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """Simulates sending a message."""
    slots = tracker.get("slots", {})
    
    print("\n--- SECURE MESSAGE (SIMULATION) ---")
    print(f"From: {slots.get('patient_id')}")
    print(f"To: {slots.get('doctor_name')}")
    print(f"Body: {slots.get('message_content')}")
    print("-----------------------------------\n")
    
    message = f"✅ Your message has been securely sent to {slots.get('doctor_name')}. They will respond via email or phone."
    
    events = [
        _active_loop(None),
        _slot_set("requested_slot", None),
        _slot_set("doctor_name", None),
        _slot_set("message_content", None),
    ]
    return create_rasa_response(events, [utter(message, buttons=[{"title": "Main Menu", "payload": "/show_options"}])])

async def handle_reschedule_cancel(tracker: Dict, session: AsyncSession) -> ActionResponse:
    """Handles flows not yet built."""
    message = "I apologize, the feature to handle rescheduling or cancellations is still in development. Please contact our support line at 555-HELP for immediate assistance."
    return create_rasa_response([], [utter(message, buttons=[{"title": "Main Menu", "payload": "/show_options"}])])




APPOINTMENT_API.PY

# backend/appointment_api.py
from fastapi import APIRouter, HTTPException, status, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import List
from sqlalchemy.orm import selectinload
from datetime import date, time, datetime

from .database import get_async_session
from . import models as db_models
from . import schemas as api_schemas

router = APIRouter(
    prefix="/appointments",
    tags=["Appointment Management"]
)

@router.get("/patient/{patient_id}", response_model=List[api_schemas.Appointment])
async def get_patient_appointments(
    patient_id: str, # This is the public PID-XXXX ID
    session: AsyncSession = Depends(get_async_session)
):
    """
    Gets all appointments for a specific patient.
    """
    result = await session.execute(
        select(db_models.Appointment)
        .join(db_models.Patient)
        .where(db_models.Patient.patient_id == patient_id)
        .options(
            selectinload(db_models.Appointment.patient),
            selectinload(db_models.Appointment.doctor),
            selectinload(db_models.Appointment.slot)
        )
        .order_by(db_models.Appointment.id.desc()) # Show most recent first
    )
    appointments = result.scalars().all()
    
    if not appointments:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No appointments found for this patient."
        )
    return appointments

@router.get("/doctors/{specialty}", response_model=List[api_schemas.Doctor])
async def get_doctors_by_specialty(
    specialty: str,
    session: AsyncSession = Depends(get_async_session)
):
    """
    Finds all doctors matching a specific specialty (e.g., "Cardiology").
    """
    result = await session.execute(
        select(db_models.Doctor).where(db_models.Doctor.specialty.ilike(f"%{specialty}%"))
    )
    doctors = result.scalars().all()
    
    if not doctors:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"No doctors found matching specialty '{specialty}'."
        )
    return doctors

@router.get("/availability/{doctor_id}/{date_str}", response_model=api_schemas.AvailabilityCheckResponse)
async def get_doctor_availability(
    doctor_id: int,
    date_str: str,
    session: AsyncSession = Depends(get_async_session)
):
    """
    Checks available (unbooked) slots for a specific doctor on a specific date.
    """
    try:
        request_date = datetime.strptime(date_str, "%Y-%m-%d").date()
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid date format. Use YYYY-MM-DD.")
        
    doctor = await session.get(db_models.Doctor, doctor_id)
    if not doctor:
        raise HTTPException(status_code=404, detail="Doctor not found.")

    result = await session.execute(
        select(db_models.AvailabilitySlot)
        .where(db_models.AvailabilitySlot.doctor_id == doctor_id)
        .where(db_models.AvailabilitySlot.date == request_date)
        .where(db_models.AvailabilitySlot.is_booked == False)
        .order_by(db_models.AvailabilitySlot.time)
    )
    slots = result.scalars().all()

    return api_schemas.AvailabilityCheckResponse(
        doctor=doctor,
        available_slots=[s.time for s in slots]
    )

@router.post("/book", response_model=api_schemas.Appointment, status_code=status.HTTP_201_CREATED)
async def book_appointment(
    appt_in: api_schemas.AppointmentCreate,
    session: AsyncSession = Depends(get_async_session)
):
    """
    Books a new appointment. This is a robust, transactional endpoint.
    """
    
    patient_result = await session.execute(
        select(db_models.Patient).where(db_models.Patient.patient_id == appt_in.patient_id)
    )
    patient = patient_result.scalars().first()
    if not patient:
        raise HTTPException(status_code=404, detail="Patient ID not found.")

    slot_result = await session.execute(
        select(db_models.AvailabilitySlot)
        .options(selectinload(db_models.AvailabilitySlot.doctor))
        .where(db_models.AvailabilitySlot.doctor_id == appt_in.doctor_id)
        .where(db_models.AvailabilitySlot.date == appt_in.date)
        .where(db_models.AvailabilitySlot.time == appt_in.time)
        .where(db_models.AvailabilitySlot.is_booked == False)
    )
    slot_to_book = slot_result.scalars().first()
    
    if not slot_to_book:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="This slot is no longer available. Please select a different time."
        )

    slot_to_book.is_booked = True
    session.add(slot_to_book)

    new_appointment = db_models.Appointment(
        patient_id=patient.id,
        doctor_id=appt_in.doctor_id,
        slot_id=slot_to_book.id,
        reason=appt_in.reason,
        status="Scheduled"
    )
    session.add(new_appointment)
    
    await session.flush()
    await session.refresh(new_appointment)

    # --- [START] THIS IS THE FIX ---
    # We must re-fetch the object with all relationships pre-loaded
    # to prevent the lazy-loading crash in the action server.
    final_appt = await session.get(
        db_models.Appointment, 
        new_appointment.id, 
        options=[
            selectinload(db_models.Appointment.patient), 
            selectinload(db_models.Appointment.doctor), 
            selectinload(db_models.Appointment.slot)
        ]
    )
    # --- [END] THIS IS THE FIX ---
    
    return final_appt



CONFIG.PY

# backend/config.py
import os
from dotenv import load_dotenv

# This line finds and loads the .env file from the root folder
load_dotenv()

# Load all your environment variables
DATABASE_URL = os.getenv("DATABASE_URL")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL")
RASA_CORE_URL = os.getenv("RASA_CORE_URL")

# Basic validation
if not DATABASE_URL:
    raise ValueError("No DATABASE_URL set in .env")
if not OLLAMA_BASE_URL:
    raise ValueError("No OLLAMA_BASE_URL set in .env")
if not RASA_CORE_URL:
    raise ValueError("No RASA_CORE_URL set in .env")



DATABASE.PY

# backend/database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from typing import AsyncGenerator # <--- IMPORT THIS

# --- [START] SECURITY FIX ---
from .config import DATABASE_URL # Import the secure URL
# --- [END] SECURITY FIX ---

if not DATABASE_URL:
    raise ValueError("No DATABASE_URL set in the .env file")

engine = create_async_engine(
    DATABASE_URL,
    echo=False,
)

AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

Base = declarative_base()

# --- [START] TYPE HINT FIX ---
# The return type is an AsyncGenerator that yields an AsyncSession
async def get_async_session() -> AsyncGenerator[AsyncSession, None]:
# --- [END] TYPE HINT FIX ---
    """
    Dependency to get an AsyncSession.
    Ensures the session is always closed.
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()


KNOWLEDGE_API.PY

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
import asyncio
from typing import List

# We will create these logic files in the next batch
from .llm_integration import query_llm 
from .rag_integration import query_rag

from .schemas import KnowledgeQueryRequest

router = APIRouter(
    prefix="/knowledge",
    tags=["Knowledge Base (RAG & LLM)"]
)

class KnowledgeQueryResponse(BaseModel):
    query: str
    response: str
    sources: List[str] = []

@router.post("/llm", response_model=KnowledgeQueryResponse)
async def handle_llm_query(request: KnowledgeQueryRequest):
    """
    Endpoint for general LLM queries (medical info, symptoms, general fallback).
    """
    try:
        response_text = await query_llm(request.query, request.patient_id)
        return KnowledgeQueryResponse(
            query=request.query,
            response=response_text
        )
    except Exception as e:
        print(f"LLM API Error: {e}")
        raise HTTPException(status_code=500, detail="Error processing LLM query.")

@router.post("/rag", response_model=KnowledgeQueryResponse)
async def handle_rag_query(request: KnowledgeQueryRequest):
    """
    Endpoint for RAG queries (insurance, hospital policy).
    Runs the synchronous RAG query in a separate thread.
    """
    try:
        loop = asyncio.get_event_loop()
        rag_result = await loop.run_in_executor(
            None,  # Use default thread pool
            query_rag, 
            request.query
        )
        
        return KnowledgeQueryResponse(
            query=request.query,
            response=rag_result.get("answer", "No answer found."),
            sources=rag_result.get("sources", [])
        )
    except Exception as e:
        print(f"RAG API Error: {e}")
        raise HTTPException(status_code=500, detail="Error processing RAG query.")


LLM_INTEGRATION.PY

# backend/llm_integration.py
import httpx
import os
from langchain_community.llms import Ollama
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from typing import Optional, Any, Dict
from .config import OLLAMA_BASE_URL
from ollama import Client, ResponseError

# --- LLM Configuration ---
try:
    client = Client(host=OLLAMA_BASE_URL)
    client.list()
    print(f"LLM Integration: Successfully connected to Ollama at {OLLAMA_BASE_URL}")
except Exception as e:
    print(f"LLM Integration: FAILED to connect to Ollama at {OLLAMA_BASE_URL}. Is it running?")
    print(f"Error: {e}")
    client = None

LLM_MODEL_NAME = "gemma:2b" 

# --- [START] FINAL AGGRESSIVE PROMPT ---
SYSTEM_PROMPT = """
You are a helpful Healthcare Assistant AI. 
Your goal is to provide general health information while avoiding specific medical advice.

RULES:
1.  **ALWAYS Answer General Questions:** If a user asks for general tips, home remedies, or definitions (e.g., "how to detox lungs", "foods for heart health", "what is asthma"), you MUST provide a helpful answer. Do NOT refuse these.
2.  **REFUSE Personal Medical Advice:** ONLY refuse if the user asks about THEIR specific condition (e.g., "Do *I* have cancer?", "Should *I* stop my meds?").
    -   If refusing, say: "I cannot provide personal medical advice. Please consult a doctor."
3.  **Keep it simple:** Write clear, short paragraphs. Do not use markdown bolding or lists.
"""
# --- [END] FINAL AGGRESSIVE PROMPT ---

def get_llm():
    """Centralized function to get the LangChain Ollama instance."""
    return Ollama(
        model=LLM_MODEL_NAME, 
        base_url=OLLAMA_BASE_URL,
        temperature=0.3, # Slightly higher temperature for more creative answers
        verbose=False
    )

async def query_llm(query: str, patient_id: Optional[str] = None) -> str:
    """
    Queries the general LLM for health FAQs, symptom checking, or fallback.
    """
    
    llm_instance = get_llm()
    # We don't need patient context for general questions, it might confuse the small model
    
    template = PromptTemplate.from_template(
        f"{SYSTEM_PROMPT}\n\nUSER QUERY: {{query}}\n\nASSISTANT:"
    )
    
    chain = template | llm_instance | StrOutputParser()
    
    try:
        response = await chain.ainvoke({"query": query})
        clean_response = response.strip().replace("**", "").replace("*", "") 
        return clean_response

    except httpx.ConnectError:
        print(f"CRITICAL: LLM Connection Error. Is Ollama running at {OLLAMA_BASE_URL}?")
        return "I'm sorry, my knowledge base is currently offline and I cannot answer that question."
    except Exception as e:
        print(f"LLM Error: {e}")
        return "I'm sorry, I encountered an error while processing your request."


MAIN.PY

# backend/main.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import httpx
from contextlib import asynccontextmanager

from .database import engine, Base, get_async_session, AsyncSessionLocal
from .models import Patient, Doctor, Appointment, AvailabilitySlot
from .utils import create_initial_data
# --- [START] RAG FIX ---
from .rag_integration import initialize_rag_pipeline
# --- [END] RAG FIX ---
from . import patient_api, appointment_api, knowledge_api, rasa_proxy, rasa_webhook

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Server: Starting up...")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    async with AsyncSessionLocal() as session:
        try:
            await create_initial_data(session)
        finally:
            await session.close()
    
    # --- [START] RAG FIX ---
    # Initialize the RAG pipeline on startup
    initialize_rag_pipeline()
    # --- [END] RAG FIX ---
    
    print("Server: Startup complete.")
    yield
    print("Server: Shutting down...")

app = FastAPI(
    title="Healthcare Chatbot Backend",
    description="API server for managing patients, appointments, and Rasa actions.",
    version="1.0.0",
    lifespan=lifespan
)

# --- Middleware ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- API Routers ---
app.include_router(patient_api.router, prefix="/api")
app.include_router(appointment_api.router, prefix="/api")
app.include_router(knowledge_api.router, prefix="/api")

# --- RASA Routers ---
app.include_router(rasa_proxy.router)
app.include_router(rasa_webhook.router)


@app.get("/", tags=["Health"])
async def read_root():
    return {"status": "Healthcare API is running"}


MODELS.PY

# backend/models.py
from sqlalchemy import Column, Integer, String, Date, Time, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from .database import Base

class Patient(Base):
    """Stores registered patient information."""
    __tablename__ = "patients"
    
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(String, unique=True, index=True, nullable=False) # Public ID
    name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    phone = Column(String, nullable=False)

    # Establishes a "one-to-many" relationship
    appointments = relationship("Appointment", back_populates="patient")

class Doctor(Base):
    """Stores doctor information and their specialization."""
    __tablename__ = "doctors"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    specialty = Column(String, index=True, nullable=False) # e.g., "Cardiology"

    # Establishes relationships
    availability_slots = relationship("AvailabilitySlot", back_populates="doctor")
    appointments = relationship("Appointment", back_populates="doctor")

class AvailabilitySlot(Base):
    """
    Stores the "master schedule" for when a doctor is available.
    Booking an appointment will set 'is_booked' to True.
    """
    __tablename__ = "availability_slots"
    
    id = Column(Integer, primary_key=True, index=True)
    doctor_id = Column(Integer, ForeignKey("doctors.id"), nullable=False)
    date = Column(Date, nullable=False)
    time = Column(Time, nullable=False) # e.g., 09:00, 09:30
    is_booked = Column(Boolean, default=False, nullable=False)

    doctor = relationship("Doctor", back_populates="availability_slots")
    appointment = relationship("Appointment", back_populates="slot", uselist=False)

class Appointment(Base):
    """Stores confirmed appointments, linking a Patient, Doctor, and Slot."""
    __tablename__ = "appointments"
    
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False)
    doctor_id = Column(Integer, ForeignKey("doctors.id"), nullable=False)
    slot_id = Column(Integer, ForeignKey("availability_slots.id"), unique=True, nullable=False)
    
    reason = Column(String, nullable=False)
    status = Column(String, default="Scheduled") # "Scheduled", "Cancelled"

    patient = relationship("Patient", back_populates="appointments")
    doctor = relationship("Doctor", back_populates="appointments")
    slot = relationship("AvailabilitySlot", back_populates="appointment")


PATIENT_API.PY

# backend/patient_api.py
from fastapi import APIRouter, HTTPException, status, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
import uuid

from .database import get_async_session
from .models import Patient
from .schemas import PatientCreate, PatientPublic, PatientLookupRequest, PatientVerifyRequest

router = APIRouter(
    prefix="/patients",
    tags=["Patient Management"]
)

@router.post("/new", response_model=PatientPublic, status_code=status.HTTP_201_CREATED)
async def register_new_patient(
    patient_in: PatientCreate, 
    session: AsyncSession = Depends(get_async_session)
):
    """
    Registers a new patient.
    Checks for duplicate emails and generates a unique public-facing Patient ID.
    """
    # Check if email already exists
    result = await session.execute(
        select(Patient).where(Patient.email == patient_in.email)
    )
    if result.scalars().first():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="A patient with this email already exists. Please try logging in."
        )
    
    # Create new patient object
    new_patient = Patient(
        patient_id=f"PID-{str(uuid.uuid4())[:8].upper()}", # e.g., PID-1234ABCD
        name=patient_in.name,
        email=patient_in.email,
        phone=patient_in.phone
    )
    
    session.add(new_patient)
    await session.flush() # Flush to get the ID before the transaction commits
    await session.refresh(new_patient)
    
    return new_patient


@router.post("/verify", response_model=PatientPublic)
async def verify_patient_id(
    verify_request: PatientVerifyRequest,
    session: AsyncSession = Depends(get_async_session)
):
    """
    Verifies a Patient ID. This is our "login" function.
    """
    result = await session.execute(
        select(Patient).where(Patient.patient_id == verify_request.patient_id.strip().upper())
    )
    patient = result.scalars().first()
    
    if not patient:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Patient ID not found. Please check the ID or register as a new user."
        )
    
    return patient


@router.post("/lookup", response_model=PatientPublic)
async def lookup_patient_by_email(
    lookup_request: PatientLookupRequest,
    session: AsyncSession = Depends(get_async_session)
):
    """
    Finds a patient by their email address (for the "Forgot ID" flow).
    """
    result = await session.execute(
        select(Patient).where(Patient.email == lookup_request.email)
    )
    patient = result.scalars().first()
    
    if not patient:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No patient account was found registered with that email address."
        )
        
    return patient


RAG_INTEGRATION.PY

# backend/rag_integration.py
import os
from langchain_community.llms import Ollama
from langchain_community.vectorstores import FAISS
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain.chains.retrieval_qa.base import RetrievalQA
from .llm_integration import get_llm
from typing import Dict, Any, List, Optional, Text

# --- Global RAG Pipeline ---
rag_qa_chain: Optional[RetrievalQA] = None

def get_mock_policy_documents():
    """
    EXPANDED knowledge base for the hospital RAG system.
    """
    return [
        # --- INSURANCE & BILLING ---
        (
            "ACCEPTED INSURANCE PLANS: We currently accept Blue Cross Blue Shield (Gold, Silver, and Platinum PPO plans), "
            "Aetna (HMO and PPO), Cigna (Open Access Plus only), and Medicare Part B. "
            "We DO NOT accept Medicaid, United Healthcare, or any international travel insurance plans at this time.",
            {"source": "Insurance Acceptance Policy 2025"}
        ),
        (
            "CO-PAYS AND DEDUCTIBLES: All co-pays are due at the time of service. "
            "For General Practice visits, the standard co-pay is $25 for accepted PPO plans. "
            "For Specialist visits (Cardiology, Neurology, Pulmonology, Endocrinology, Dermatology), the standard co-pay is $50. "
            "Patients attempting to use out-of-network insurance will be required to pay 50% of the estimated cost upfront.",
            {"source": "Billing & Payment Guide"}
        ),
        (
            "SELF-PAY PATIENTS: Patients without insurance (self-pay) are eligible for a 20% discount if the bill is paid in full within 15 days of service. "
            "We offer interest-free payment plans for bills over $500, verifiable through our billing department.",
            {"source": "Financial Assistance Policy"}
        ),

        # --- APPOINTMENTS & CANCELLATIONS ---
        (
            "CANCELLATION POLICY: We require 24-hour notice for all cancellations. "
            "Cancellations made less than 24 hours before the scheduled time will incur a $25 late cancellation fee. "
            "Patients who 'no-show' (do not attend without calling) will be charged a $50 fee and may be restricted from future booking.",
            {"source": "Appointment Rules"}
        ),
        (
            "LATE ARRIVALS: If you arrive more than 15 minutes late for your appointment, you may be asked to reschedule, "
            "or you may have to wait until the doctor has an opening between other patients.",
            {"source": "Appointment Rules"}
        ),

        # --- HOSPITAL FACILITIES & VISITING ---
        (
            "VISITING HOURS: General Ward visiting hours are from 10:00 AM to 8:00 PM daily. "
            "ICU (Intensive Care Unit) visiting hours are restricted to 12:00 PM - 2:00 PM and 6:00 PM - 8:00 PM only. "
            "Only 2 visitors are allowed per patient at a time in General Wards, and only 1 in the ICU.",
            {"source": "Visitor Guide"}
        ),
        (
            "PARKING: Patient and visitor parking is available in the North Garage (attached to the main building). "
            "Parking is free for the first 30 minutes. Rates are $3 per hour thereafter, with a maximum daily rate of $15. "
            "Valet parking is available at the main entrance for a flat fee of $20.",
            {"source": "Facility Guide"}
        ),
        (
            "CAFETERIA: The hospital cafeteria 'Healthy Bites' is located on the 2nd floor. "
            "It is open from 6:30 AM to 7:00 PM daily. Vending machines are available 24/7 on every floor near the elevators.",
            {"source": "Facility Guide"}
        ),

        # --- MEDICAL RECORDS & PRIVACY ---
        (
            "REQUESTING MEDICAL RECORDS: Patients may request copies of their medical records by submitting form MR-101 to the Health Information Management department. "
            "Processing typically takes 5-7 business days. There is no fee for records sent directly to another healthcare provider. "
            "Personal copies may incur a printing fee of $0.10 per page.",
            {"source": "Medical Records Policy"}
        ),
        (
            "PATIENT PRIVACY (HIPAA): We strictly adhere to HIPAA regulations. We cannot discuss a patient's condition with anyone "
            "unless they are listed on the patient's approved HIPAA release form, which must be updated annually.",
            {"source": "Privacy Policy"}
        )
    ]

def initialize_rag_pipeline():
    """
    Called on FastAPI startup. Loads documents, creates embeddings,
    and builds the QA chain.
    """
    global rag_qa_chain
    
    if rag_qa_chain:
        print("RAG: Pipeline already initialized.")
        return

    print("RAG: Initializing RAG pipeline...")
    
    docs_data = get_mock_policy_documents()
    texts = [d[0] for d in docs_data]
    metadatas = [d[1] for d in docs_data]
    
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=50)
    splits = text_splitter.create_documents(texts, metadatas=metadatas)
    
    print("RAG: Loading HuggingFace embeddings model...")
    # Updated to avoid deprecation warning if possible, but keeping compatible
    model_name = "sentence-transformers/all-MiniLM-L6-v2"
    embeddings = HuggingFaceEmbeddings(model_name=model_name)
    
    print(f"RAG: Creating FAISS vector store with {len(splits)} chunks...")
    faiss_index = FAISS.from_documents(splits, embeddings)
    retriever = faiss_index.as_retriever(search_kwargs={"k": 3}) # Increased to k=3 for better context
    
    llm = get_llm()
    rag_qa_chain = RetrievalQA.from_chain_type(
        llm=llm,
        chain_type="stuff",
        retriever=retriever,
        return_source_documents=True
    )
    
    print("RAG: Pipeline successfully initialized.")

def query_rag(query: str) -> Dict[Text, Any]:
    global rag_qa_chain
    if not rag_qa_chain:
        print("RAG Error: RAG pipeline not initialized.")
        return {"answer": "Error: The knowledge base is not available.", "sources": []}

    prompt = (
        "You are a professional hospital policy and insurance specialist. "
        "Your task is to answer the user's question **using ONLY the provided context documents**. "
        "Do not use any outside knowledge. If the answer is not in the context, "
        "you MUST state: 'I'm sorry, I cannot find that specific information in our policy documents.'\n\n"
        f"CONTEXT:\n{{context}}\n\nUSER QUESTION: {query}"
    )
    
    rag_qa_chain.combine_documents_chain.llm_chain.prompt.template = prompt
    result = rag_qa_chain.invoke(query)
    
    sources = []
    if result.get("source_documents"):
        sources = list(set([doc.metadata.get("source", "Unknown") for doc in result["source_documents"]]))

    return {
        "answer": result.get("result", "No answer found."),
        "sources": sources
    }


RASA_PROXY.PY

# backend/rasa_proxy.py
from fastapi import APIRouter, Request, HTTPException
from fastapi.responses import JSONResponse
import httpx

# --- [START] SECURITY FIX ---
from .config import RASA_CORE_URL
# --- [END] SECURITY FIX ---

router = APIRouter()
RASA_TIMEOUT = 30.0  # 30-second timeout

@router.post("/chat")
async def proxy_rasa_chat(request: Request):
    """
    Proxies chat messages from the frontend to the Rasa Core server.
    This is what your index.html talks to.
    """
    body = await request.json()
    
    async with httpx.AsyncClient(timeout=RASA_TIMEOUT) as client:
        try:
            response = await client.post(
                RASA_CORE_URL, # Use the secure URL
                json=body
            )
            response.raise_for_status()
            return JSONResponse(content=response.json(), status_code=response.status_code)
        
        except httpx.ConnectError:
            print(f"Rasa Proxy Error: Cannot connect to Rasa Core at {RASA_CORE_URL}.")
            raise HTTPException(
                status_code=503, 
                detail=f"Cannot connect to Rasa Core server."
            )
        except httpx.HTTPStatusError as e:
            print(f"Rasa Proxy Error: {e.response.status_code} - {e.response.text}")
            raise HTTPException(
                status_code=e.response.status_code, 
                detail=e.response.json()
            )
        except Exception as e:
            print(f"Rasa Proxy Error: An unexpected error occurred: {e}")
            raise HTTPException(status_code=500, detail="Internal proxy error")



RASA_WEBHOOK.PY

# backend/rasa_webhook.py
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.ext.asyncio import AsyncSession
import traceback 

# --- [START] NEW SESSION IMPORT ---
from .database import AsyncSessionLocal
# --- [END] NEW SESSION IMPORT ---

from .schemas import RasaActionCall
from .actions_logic import (
    handle_session_start, handle_restart_conversation, handle_suggest_next_steps,
    handle_validate_simple_info_form, handle_create_new_patient,
    handle_login_patient, handle_validate_lookup_form, handle_lookup_patient_id,
    handle_validate_appointment_form, handle_submit_appointment,
    handle_llm_response, handle_rag_insurance_query,
    handle_validate_physician_form, handle_send_physician_message,
    handle_reschedule_cancel,
    handle_show_appointments,
    handle_validate_medical_form,
    handle_validate_insurance_form,
    create_rasa_response, 
    utter
)

router = APIRouter()

# Maps action names from Rasa to our Python functions
ACTION_MAPPING = {
    "action_session_start": handle_session_start,
    "action_restart_conversation": handle_restart_conversation,
    "action_suggest_next_steps": handle_suggest_next_steps,
    
    # Registration
    "validate_simple_info_form": handle_validate_simple_info_form,
    "action_create_new_patient": handle_create_new_patient,
    
    # Login / Lookup
    "action_login_patient": handle_login_patient,
    "validate_lookup_form": handle_validate_lookup_form,
    "action_lookup_patient_id": handle_lookup_patient_id,
    
    # Appointments
    "validate_appointment_form": handle_validate_appointment_form,
    "action_submit_appointment": handle_submit_appointment,
    "action_show_appointments": handle_show_appointments,
    "action_reschedule_cancel": handle_reschedule_cancel,
    
    # Knowledge
    "validate_medical_form": handle_validate_medical_form,
    "action_llm_response": handle_llm_response,
    "validate_insurance_form": handle_validate_insurance_form,
    "action_rag_insurance_query": handle_rag_insurance_query,

    # Physician Contact
    "validate_physician_form": handle_validate_physician_form,
    "action_send_physician_message": handle_send_physician_message,
}

# --- [START] NEW WEBHOOK LOGIC ---
# This logic creates its own session, executes the action, and closes it.
# This is the fix for the "greenlet_spawn" error.
@router.post("/rasa/webhook")
async def rasa_action_webhook(call: RasaActionCall):
    """
    This is the main endpoint that Rasa Core talks to.
    It creates its own session for each action call.
    """
    action_function = ACTION_MAPPING.get(call.next_action)

    if not action_function:
        print(f"Action '{call.next_action}' not found.")
        raise HTTPException(
            status_code=404, 
            detail=f"Action '{call.next_action}' not found."
        )

    print(f"Executing action: {call.next_action}")
    
    # Create a new, independent session for this action
    async with AsyncSessionLocal() as session:
        try:
            response = await action_function(call.tracker, session)
            await session.commit()
            return response
        
        except Exception as e:
            print(f"Error executing action '{call.next_action}':")
            print(traceback.format_exc()) 
            
            await session.rollback()
            
            return create_rasa_response(
                [], 
                [utter(f"I'm sorry, an internal error occurred while running '{call.next_action}'. Please check the server logs.")]
            )
# --- [END] NEW WEBHOOK LOGIC ---


REQUIREMENTS.TXT

# backend/requirements.txt
# For the FastAPI, RAG, and LLM backend

# --- FastAPI & Backend ---
fastapi==0.109.2
uvicorn==0.27.1
sqlalchemy==2.0.25
asyncpg==0.29.0

# --- RAG & LLM LIBRARIES (Aligned to 0.3.x) ---
langchain==0.3.0
langchain-community==0.3.0
langchain-core==0.3.0
langchain-text-splitters==0.3.0
langchain-ollama==0.2.0

sentence-transformers==2.7.0
faiss-cpu==1.8.0

python-dotenv



SCHEMAS.PY

# backend/schemas.py
from pydantic import BaseModel, EmailStr, ConfigDict
from typing import List, Optional
from datetime import date, time

# --- Base Configuration ---
class BaseSchema(BaseModel):
    model_config = ConfigDict(from_attributes=True) # Pydantic v2 "orm_mode"

# --- Patient Schemas ---
class PatientCreate(BaseModel):
    name: str
    email: EmailStr
    phone: str

class Patient(BaseSchema):
    id: int
    patient_id: str
    name: str
    email: EmailStr
    phone: str

class PatientPublic(BaseModel):
    """Data returned to the user after login or registration."""
    patient_id: str
    name: str
    email: EmailStr

# --- Doctor & Availability Schemas ---
class Doctor(BaseSchema):
    id: int
    name: str
    specialty: str

class AvailabilitySlot(BaseSchema):
    id: int
    date: date
    time: time
    is_booked: bool

class AvailabilityCheckResponse(BaseModel):
    doctor: Doctor
    available_slots: List[time] # List of available times for the given date

# --- Appointment Schemas ---
class AppointmentBase(BaseModel):
    reason: str
    doctor_id: int
    date: date

class AppointmentCreate(AppointmentBase):
    """Schema used to request a new appointment."""
    patient_id: str # The public-facing patient ID
    time: time # The specific time slot requested

class Appointment(BaseSchema):
    """Full appointment details for API responses."""
    id: int
    reason: str
    status: str
    patient: PatientPublic # Nested patient details
    doctor: Doctor # Nested doctor details
    slot: AvailabilitySlot # Nested slot details

# --- Rasa Action & Query Schemas ---
class RasaActionCall(BaseModel):
    """The webhook payload Rasa sends to our action server."""
    next_action: str
    tracker: dict
    domain: dict

class RasaChatRequest(BaseModel):
    """The payload from our frontend to the /chat proxy."""
    sender: str
    message: str

class KnowledgeQueryRequest(BaseModel):
    """Payload for RAG/LLM queries."""
    query: str
    patient_id: Optional[str] = None

# --- [START] CRITICAL FIX ---
# These models were missing, causing the import error.
class PatientVerifyRequest(BaseModel):
    """Schema for verifying patient login."""
    patient_id: str

class PatientLookupRequest(BaseModel):
    """Schema for looking up Patient ID via email."""
    email: EmailStr
# --- [END] CRITICAL FIX ---


UTILS.PY


# backend/utils.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from datetime import time, date, timedelta

from .models import Doctor, AvailabilitySlot

async def create_initial_data(session: AsyncSession):
    """
    Populates the database with initial Doctors and their Availability.
    This runs on application startup if the tables are empty.
    """
    
    result = await session.execute(select(Doctor))
    if result.scalars().first() is not None:
        print("Database: Doctors already exist. Skipping population.")
        return

    print("Database: No doctors found. Populating initial data...")

    # --- 1. Create Doctors (25 total) ---
    doc_gp1 = Doctor(name="Dr. Chloe Li", specialty="General Practice")
    doc_gp2 = Doctor(name="Dr. Alex Ray", specialty="General Practice")
    doc_gp3 = Doctor(name="Dr. Emily White", specialty="General Practice")
    doc_gp4 = Doctor(name="Dr. Michael Brown", specialty="General Practice")
    doc_gp5 = Doctor(name="Dr. Sarah Jenkins", specialty="General Practice")
    doc_card1 = Doctor(name="Dr. Anya Sharma", specialty="Cardiology")
    doc_card2 = Doctor(name="Dr. Ben Carter", specialty="Cardiology")
    doc_card3 = Doctor(name="Dr. David Lee", specialty="Cardiology")
    doc_card4 = Doctor(name="Dr. Rachel Kim", specialty="Cardiology")
    doc_card5 = Doctor(name="Dr. Steven Chen", specialty="Cardiology")
    doc_pul1 = Doctor(name="Dr. Lisa Wong", specialty="Pulmonology")
    doc_pul2 = Doctor(name="Dr. Kenji Tanaka", specialty="Pulmonology")
    doc_pul3 = Doctor(name="Dr. Maria Garcia", specialty="Pulmonology")
    doc_pul4 = Doctor(name="Dr. Tom Baker", specialty="Pulmonology")
    doc_pul5 = Doctor(name="Dr. Laura Scott", specialty="Pulmonology")
    doc_derm1 = Doctor(name="Dr. James Wilson", specialty="Dermatology")
    doc_derm2 = Doctor(name="Dr. Priya Patel", specialty="Dermatology")
    doc_derm3 = Doctor(name="Dr. Omar Hassan", specialty="Dermatology")
    doc_derm4 = Doctor(name="Dr. Helen Cho", specialty="Dermatology")
    doc_derm5 = Doctor(name="Dr. Mark Reid", specialty="Dermatology")
    doc_endo1 = Doctor(name="Dr. Sam Kumar", specialty="Endocrinology")
    doc_endo2 = Doctor(name="Dr. Alice Fay", specialty="Endocrinology")
    doc_endo3 = Doctor(name="Dr. Robert Green", specialty="Endocrinology")
    doc_endo4 = Doctor(name="Dr. Fiona Bale", specialty="Endocrinology")
    doc_endo5 = Doctor(name="Dr. Ivan Petrov", specialty="Endocrinology")

    all_doctors = [
        doc_gp1, doc_gp2, doc_gp3, doc_gp4, doc_gp5,
        doc_card1, doc_card2, doc_card3, doc_card4, doc_card5,
        doc_pul1, doc_pul2, doc_pul3, doc_pul4, doc_pul5,
        doc_derm1, doc_derm2, doc_derm3, doc_derm4, doc_derm5,
        doc_endo1, doc_endo2, doc_endo3, doc_endo4, doc_endo5
    ]
    session.add_all(all_doctors)
    await session.flush()

    # --- 2. Create Availability Slots (EXPANDED TO 60 DAYS) ---
    available_times = [
        time(9, 0), time(9, 30), time(10, 0), time(10, 30),
        time(11, 0), time(11, 30), time(12, 0), time(12, 30),
        time(13, 0), time(13, 30), time(14, 0), time(14, 30), 
        time(15, 0), time(15, 30), time(16, 0), time(16, 30), 
        time(17, 0), time(17, 30), time(18, 0), time(18, 30),
        time(19, 0), time(19, 30)
    ]
    
    slots_to_create = []
    today = date.today()
    
    for doctor in all_doctors:
        # --- FIX: Increased from 7 to 60 days ---
        for i in range(60): 
            slot_date = today + timedelta(days=i)
            # Skip weekends for realism (optional, but good practice)
            if slot_date.weekday() < 5: # 0-4 are Mon-Fri
                for slot_time in available_times:
                    slots_to_create.append(
                        AvailabilitySlot(
                            doctor_id=doctor.id,
                            date=slot_date,
                            time=slot_time
                        )
                    )

    session.add_all(slots_to_create)
    await session.commit()
    print(f"Database: Successfully added {len(all_doctors)} doctors and {len(slots_to_create)} availability slots.")

